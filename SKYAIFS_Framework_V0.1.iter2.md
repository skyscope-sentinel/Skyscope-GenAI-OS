# SKYAIFS (Skyscope AI Filesystem) Conceptual Framework - V0.1 - Iteration 2

**Based on:** `SKYAIFS_Framework_V0.1.iter1.md`
**Key Reference:** `SILA_Specification_V0.2.md`
**Iteration Focus:** AI Bot SILA IPC protocols, resilience/self-healing logic in SILA, detailed data relocation workflow, refined SILA file descriptors.

## 1. Core Principles
Retained from Iteration 1. SILA V0.2, with its PQC-aware types (min 4096-bit security, e.g., MLKEM_1024 for encryption, MLDSA_5 for signatures), Asynchronous Actor-like SILA Agents (ASAs), and verifiable contracts, remains the implementation foundation for SKYAIFS.

## 2. Dynamic Block/Sector Management (SILA V0.2 Alignment)
Retained from Iteration 1. Key elements include `SILA_SKYAIFS_LogicalBlock_Descriptor_Record` (with `storage_location_cap` and `encryption_key_ref_cap`) and the "SKYAIFS_AllocationManager_ASA" managing free space via PQC-signed SILA graph structures.

## 3. AI Bot Orchestration (SILA V0.2 Implementation)

### 3.1. Bot Representation as SILA ASAs
Retained from Iteration 1. A `SKYAIFS_Supervisor_ASA` orchestrates specialized bot ASAs (Defragmentation, Data Relocation, Predictive Placement, Integrity Verification) using SILA IPC.

### 3.2. AI Bot Interaction Protocols (SILA IPC)
SILA IPC messages are defined as SILA Records, ensuring type safety and enabling PQC protection if messages cross trust boundaries defined by SILA policies.

*   **Integrity Bot ASA to Supervisor ASA (Event Notification):**
    *   Message Type: `SILA_IntegrityAnomaly_Detected_Event_Record`
    *   Content:
        `{
          event_id: SILA_UniqueID_String,
          timestamp: SILA_Timestamp_Record,
          reporting_bot_id_cap: SILA_CapToken<IntegrityBot_ASA_Type>,
          affected_logical_block_desc_cap: SILA_CapToken<SILA_SKYAIFS_LogicalBlock_Descriptor_Record>,
          expected_pqc_checksum: SILA_PQC_Hash_Record<SHA3_256>,
          computed_pqc_checksum: SILA_PQC_Hash_Record<SHA3_256>,
          severity_level_enum: SILA_Severity_Enum // e.g., Critical, Warning
        }`
    *   Sent via a standard SILA `SendEvent_Operation` to the Supervisor ASA's registered event handler endpoint. The payload can be PQC-encrypted using a session key established with the Supervisor if required by policy.

*   **Supervisor ASA to Relocation Bot ASA (Command):**
    *   Message Type: `SILA_InitiateDataRelocation_Command_Record`
    *   Content:
        `{
          command_id: SILA_UniqueID_String,
          issuing_supervisor_id_cap: SILA_CapToken<SKYAIFS_Supervisor_ASA_Type>,
          target_file_descriptor_caps_array: SILA_Array<SILA_CapToken<SILA_SKYAIFS_File_Descriptor_Record>>, // Files to relocate
          triggering_threat_context_ref: SILA_Optional<SILA_CapToken<SILA_ThreatIntel_Report_Type>>, // Reference to threat data
          destination_storage_policy_cap: SILA_CapToken<SILA_StorageZoneSelectionPolicy_Record>, // Policy for choosing secure zone
          relocation_priority_enum: SILA_Priority_Enum
        }`
    *   Sent via SILA IPC `Call_Operation` (if synchronous acknowledgement of command receipt is needed) or `SendCommand_Operation`.

*   **Relocation Bot ASA to Key Management ASA (Service Request):**
    *   Message Type: `SILA_RequestNewPQCKeys_ServiceOperation_Record`
    *   Content:
        `{
          requesting_bot_id_cap: SILA_CapToken<RelocationBot_ASA_Type>,
          number_of_keys_required: SILA_Verifiable_Integer,
          key_specification_ref_cap: SILA_CapToken<SILA_PQC_KeyGenerationPolicy_Record> // Specifies type like MLKEM_1024, usage flags
        }`
    *   Response Message Type: `SILA_NewPQCKeys_ServiceResponse_Record`
    *   Content:
        `{
          request_id_ref: SILA_UniqueID_String, // Correlates to request
          generated_key_object_caps_array: SILA_Array<SILA_CapToken<SILA_PQC_Key_Object_Type>>,
          status_enum: SILA_OperationStatus_Enum
        }`

### 3.3. Bot Policies in SILA
Retained from Iteration 1. `SILA_ExecutionPolicy_Record` structures, PQC-signed and bound to bot ASAs, govern their behavior. These policies are interpreted by the SILA runtime and verifier.

### 3.4. Resilience & Self-Healing Logic in SILA
Leveraging SILA V0.2 fault tolerance patterns and verifiable contracts:

*   **Redundant Metadata Storage & Operations:** Critical SKYAIFS metadata (e.g., root of the filesystem Merkle tree, allocation manager state) can be managed with a policy of N-way replication. Updates would use a SILA graph pattern generated by the ADK: `ADK_Generate_QuorumWrite_SILA_Pattern(target_metadata_type_cap, data_to_write_sila_record, replica_location_caps_array, quorum_needed_int)`. The pattern would handle parallel writes and verify quorum success, returning a `SILA_Result_Union`. The contract for this pattern would specify its atomicity and consistency properties.
*   **Automated Metadata Recovery (using SILA ASA Logic & Contracts):**
    *   If the `SKYAIFS_Supervisor_ASA` receives multiple `SILA_IntegrityAnomaly_Detected_Event_Record` messages for a critical metadata structure, it can activate a "SKYAIFS_RecoveryBot_ASA".
    *   This RecoveryBot ASA would:
        1.  Attempt to read alternative PQC-signed replicas of the corrupted metadata (using `SILA_CapToken`s to replica locations).
        2.  Use `ADK_Generate_Retry_SILA_Pattern` for potentially transient read failures from replicas.
        3.  If a valid replica is found (PQC signature verified), it initiates a "metadata repair" operation (another SILA graph) to restore/replace the corrupted version. This operation's `SILA_Module_Contract_Record` would specify its safety postconditions.
        4.  If no valid replica is found, it escalates to a higher-level system recovery agent, sending a detailed `SILA_UnrecoverableFSError_Event`.
*   **Circuit Breaker for Failing Storage Capabilities (SILA Pattern):**
    *   A "SKYAIFS_StorageHealthMonitor_ASA" continuously monitors I/O error events (SILA messages) from the Microkernel related to specific `SILA_CapToken<SILA_Microkernel_RawBlockDevice_Area_Type>`.
    *   If error rates for a storage capability exceed thresholds defined in a `SILA_StorageHealth_Policy_Record`, the Monitor ASA invokes an ADK-generated Circuit Breaker SILA pattern: `ADK_Generate_CircuitBreaker_SILA_Pattern(failing_storage_cap, circuit_breaker_policy_cap)`.
    *   This pattern would make the `failing_storage_cap` temporarily unavailable for new allocations by the `SKYAIFS_AllocationManager_ASA` and trigger proactive data relocation from that storage area by the `SKYAIFS_DataRelocationBot_ASA`.

### 3.5. Dynamic Data Relocation Workflow (Conceptual SILA State Machine for Relocation Bot ASA)
The `SILA_Define_StateMachine(SKYAIFS_DataRelocationBot_SM)` from Iteration 1 is enhanced:

*   **State: `ValidateThreat`:**
    *   Receives `SILA_InitiateDataRelocation_Command_Record`.
    *   If `triggering_threat_context_ref` is present, sends a SILA IPC message to a "ThreatAnalysis_Service_ASA" with the context capability to get a validated `SILA_ThreatAssessment_Record`. This interaction has its own contract.
*   **State: `SelectSecureZone`:**
    *   Queries a "StorageZoneManager_ASA" via SILA IPC, passing the `destination_storage_policy_cap` and `ValidatedThreatContext_SILA_Struct`. Receives a list of suitable `SILA_CapToken<SILA_Microkernel_RawBlockDevice_Area_Type>` for the new data.
*   **State: `AcquireNewKeys`:** Sends `SILA_RequestNewPQCKeys_ServiceOperation_Record` to "KeyManagement_ASA".
*   **State: `CopyAndReEncrypt`:** This complex state involves a loop or parallel SILA graph execution for each block of the source file(s).
    *   For each block:
        1.  Microkernel `SILA_ReadBlock_Op` (using source storage cap).
        2.  `SILA_PQC_Decrypt_Op` using old key capability.
        3.  `SILA_PQC_Encrypt_Op` using a newly acquired key capability (from `AcquireNewKeys` state).
        4.  Microkernel `SILA_WriteBlock_Op` (using target secure zone storage cap).
    *   All operations use `SILA_Result_Union` for error handling. A failure here might trigger a rollback strategy defined in the bot's policy.
*   **State: `UpdateMetadataReferences`:** This is a critical atomic sequence. It involves creating *new versions* of the file's `SILA_SKYAIFS_File_Descriptor_Record` and its entry in the parent directory's listing (both PQC-signed immutable SILA structures). The old versions are marked stale or superseded in the metadata graph. This uses SILA operations that ensure consistency of the metadata graph.
*   **State: `QueueOldDataForSecureErase`:** Sends a SILA message to a "SecureErase_Service_ASA" containing capabilities to the old physical blocks. This service then performs PQC-compliant data sanitization.

## 4. PQC Integration (SILA V0.2 Types & Operations)
Retained from Iteration 1. The use of SILA V0.2 PQC-aware types (e.g., `SILA_PQC_Encrypted<MLKEM_1024, ...>`, `SILA_PQC_Signed<MLDSA_5, ...>`) and SILA cryptographic primitives is fundamental. Min 4096-bit equivalent security is enforced by the specific SILA types selected (e.g., MLKEM_1024 corresponds to NIST Level V).

## 5. Interface with Microkernel (SILA V0.2 APIs)
Retained from Iteration 1. SKYAIFS ASAs use formal SILA IPC to call Microkernel services, all mediated by capabilities.

## 6. SILA Structures for File Handles/Descriptors (Refined)
The `SILA_SKYAIFS_OpenFileHandle_Record` from Iteration 1 is refined:
`SILA_SKYAIFS_OpenFileHandle_Record {
  handle_id: SILA_UniqueID_String, // Unique ID for this open instance
  file_descriptor_versioned_cap: SILA_CapToken<SILA_Versioned_SKYAIFS_File_Descriptor_Type>, // Capability to a specific, PQC-signed version of the file metadata
  session_id: SILA_SessionID_Record,
  current_offset: SILA_Verifiable_Integer,
  access_rights_for_session: SILA_FileAccessRights_Enum_Set, // e.g., {Read, Append} - subset of file's actual perms
  session_pqc_policy_ref: SILA_Optional<SILA_CapToken<SILA_PQC_SessionPolicy_Record>>, // e.g., for ephemeral keys for read/write integrity for this session
  lock_state: SILA_FileLockState_Enum, // e.g., NoLock, ReadLock, WriteLock
  associated_asa_cap: SILA_CapToken<Calling_ASA_Type> // Capability to the ASA that opened the file
}`
*   The `file_descriptor_versioned_cap` ensures that the handle is tied to a consistent, immutable snapshot of the file's metadata at the time of opening or last synchronization.
*   Operations like `SILA_SKYAIFS_Read_Operation(handle_cap, buffer_cap, length)` now take this handle capability. SKYAIFS uses the `file_descriptor_versioned_cap` within the handle to access the relevant metadata version for block lookups.

## Iteration 2 Conclusion
This iteration has significantly deepened the SKYAIFS framework's alignment with SILA V0.2 by:
1.  Detailing conceptual SILA IPC message structures for AI bot interactions.
2.  Providing more specific examples of how SILA's fault tolerance patterns and verifiable contracts can be applied to achieve resilience and self-healing in metadata operations and storage health monitoring.
3.  Outlining a more comprehensive SILA state machine and interaction flow for the critical Data Relocation Bot, emphasizing secure key management and immutable metadata updates.
4.  Refining the SILA structure for application file handles to securely encapsulate session-specific rights and a versioned reference to file metadata.
The foundation is now stronger for AI agents to begin generating more detailed SILA graph logic for these SKYAIFS components.The file `SKYAIFS_Framework_V0.1.iter2.md` has been successfully created with the specified enhancements.

This completes the simulation of Iteration 2 for the SKYAIFS Conceptual Framework. The next step is to report this completion.
